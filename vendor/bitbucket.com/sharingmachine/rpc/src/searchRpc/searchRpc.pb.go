// Code generated by protoc-gen-go.
// source: searchRpc.proto
// DO NOT EDIT!

/*
Package searchRpc is a generated protocol buffer package.

It is generated from these files:
	searchRpc.proto

It has these top-level messages:
	AlphaRequest
	AlphaResponse
	AlphaResult
*/
package searchRpc

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type AlphaRequest struct {
	Term      string `protobuf:"bytes,1,opt,name=term" json:"term,omitempty"`
	Runtime   string `protobuf:"bytes,2,opt,name=runtime" json:"runtime,omitempty"`
	Extension string `protobuf:"bytes,3,opt,name=extension" json:"extension,omitempty"`
	Username  string `protobuf:"bytes,4,opt,name=username" json:"username,omitempty"`
	All       bool   `protobuf:"varint,5,opt,name=all" json:"all,omitempty"`
	Global    bool   `protobuf:"varint,6,opt,name=global" json:"global,omitempty"`
}

func (m *AlphaRequest) Reset()                    { *m = AlphaRequest{} }
func (m *AlphaRequest) String() string            { return proto.CompactTextString(m) }
func (*AlphaRequest) ProtoMessage()               {}
func (*AlphaRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *AlphaRequest) GetTerm() string {
	if m != nil {
		return m.Term
	}
	return ""
}

func (m *AlphaRequest) GetRuntime() string {
	if m != nil {
		return m.Runtime
	}
	return ""
}

func (m *AlphaRequest) GetExtension() string {
	if m != nil {
		return m.Extension
	}
	return ""
}

func (m *AlphaRequest) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *AlphaRequest) GetAll() bool {
	if m != nil {
		return m.All
	}
	return false
}

func (m *AlphaRequest) GetGlobal() bool {
	if m != nil {
		return m.Global
	}
	return false
}

type AlphaResponse struct {
	Results []*AlphaResult `protobuf:"bytes,1,rep,name=results" json:"results,omitempty"`
	Total   int64          `protobuf:"varint,2,opt,name=total" json:"total,omitempty"`
	Took    int64          `protobuf:"varint,3,opt,name=took" json:"took,omitempty"`
}

func (m *AlphaResponse) Reset()                    { *m = AlphaResponse{} }
func (m *AlphaResponse) String() string            { return proto.CompactTextString(m) }
func (*AlphaResponse) ProtoMessage()               {}
func (*AlphaResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *AlphaResponse) GetResults() []*AlphaResult {
	if m != nil {
		return m.Results
	}
	return nil
}

func (m *AlphaResponse) GetTotal() int64 {
	if m != nil {
		return m.Total
	}
	return 0
}

func (m *AlphaResponse) GetTook() int64 {
	if m != nil {
		return m.Took
	}
	return 0
}

type AlphaResult struct {
	SnipId            string            `protobuf:"bytes,1,opt,name=snipId" json:"snipId,omitempty"`
	Username          string            `protobuf:"bytes,2,opt,name=username" json:"username,omitempty"`
	Key               string            `protobuf:"bytes,3,opt,name=key" json:"key,omitempty"`
	Runtime           string            `protobuf:"bytes,4,opt,name=runtime" json:"runtime,omitempty"`
	FullKey           string            `protobuf:"bytes,18,opt,name=fullKey" json:"fullKey,omitempty"`
	Extension         string            `protobuf:"bytes,10,opt,name=extension" json:"extension,omitempty"`
	Snip              string            `protobuf:"bytes,5,opt,name=snip" json:"snip,omitempty"`
	SnipVersion       int64             `protobuf:"varint,6,opt,name=snipVersion" json:"snipVersion,omitempty"`
	Created           int64             `protobuf:"varint,8,opt,name=created" json:"created,omitempty"`
	Tags              []string          `protobuf:"bytes,9,rep,name=tags" json:"tags,omitempty"`
	Highlights        map[string]string `protobuf:"bytes,11,rep,name=highlights" json:"highlights,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	ForkedFromFullKey string            `protobuf:"bytes,12,opt,name=forkedFromFullKey" json:"forkedFromFullKey,omitempty"`
	ForkedFromVersion int64             `protobuf:"varint,13,opt,name=forkedFromVersion" json:"forkedFromVersion,omitempty"`
	RunCount          int64             `protobuf:"varint,14,opt,name=runCount" json:"runCount,omitempty"`
	CloneCount        int64             `protobuf:"varint,15,opt,name=cloneCount" json:"cloneCount,omitempty"`
	Description       string            `protobuf:"bytes,16,opt,name=description" json:"description,omitempty"`
	Private           string            `protobuf:"bytes,17,opt,name=private" json:"private,omitempty"`
}

func (m *AlphaResult) Reset()                    { *m = AlphaResult{} }
func (m *AlphaResult) String() string            { return proto.CompactTextString(m) }
func (*AlphaResult) ProtoMessage()               {}
func (*AlphaResult) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *AlphaResult) GetSnipId() string {
	if m != nil {
		return m.SnipId
	}
	return ""
}

func (m *AlphaResult) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *AlphaResult) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *AlphaResult) GetRuntime() string {
	if m != nil {
		return m.Runtime
	}
	return ""
}

func (m *AlphaResult) GetFullKey() string {
	if m != nil {
		return m.FullKey
	}
	return ""
}

func (m *AlphaResult) GetExtension() string {
	if m != nil {
		return m.Extension
	}
	return ""
}

func (m *AlphaResult) GetSnip() string {
	if m != nil {
		return m.Snip
	}
	return ""
}

func (m *AlphaResult) GetSnipVersion() int64 {
	if m != nil {
		return m.SnipVersion
	}
	return 0
}

func (m *AlphaResult) GetCreated() int64 {
	if m != nil {
		return m.Created
	}
	return 0
}

func (m *AlphaResult) GetTags() []string {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *AlphaResult) GetHighlights() map[string]string {
	if m != nil {
		return m.Highlights
	}
	return nil
}

func (m *AlphaResult) GetForkedFromFullKey() string {
	if m != nil {
		return m.ForkedFromFullKey
	}
	return ""
}

func (m *AlphaResult) GetForkedFromVersion() int64 {
	if m != nil {
		return m.ForkedFromVersion
	}
	return 0
}

func (m *AlphaResult) GetRunCount() int64 {
	if m != nil {
		return m.RunCount
	}
	return 0
}

func (m *AlphaResult) GetCloneCount() int64 {
	if m != nil {
		return m.CloneCount
	}
	return 0
}

func (m *AlphaResult) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *AlphaResult) GetPrivate() string {
	if m != nil {
		return m.Private
	}
	return ""
}

func init() {
	proto.RegisterType((*AlphaRequest)(nil), "searchRpc.AlphaRequest")
	proto.RegisterType((*AlphaResponse)(nil), "searchRpc.AlphaResponse")
	proto.RegisterType((*AlphaResult)(nil), "searchRpc.AlphaResult")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for SearchRpc service

type SearchRpcClient interface {
	Alpha(ctx context.Context, in *AlphaRequest, opts ...grpc.CallOption) (*AlphaResponse, error)
}

type searchRpcClient struct {
	cc *grpc.ClientConn
}

func NewSearchRpcClient(cc *grpc.ClientConn) SearchRpcClient {
	return &searchRpcClient{cc}
}

func (c *searchRpcClient) Alpha(ctx context.Context, in *AlphaRequest, opts ...grpc.CallOption) (*AlphaResponse, error) {
	out := new(AlphaResponse)
	err := grpc.Invoke(ctx, "/searchRpc.SearchRpc/Alpha", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for SearchRpc service

type SearchRpcServer interface {
	Alpha(context.Context, *AlphaRequest) (*AlphaResponse, error)
}

func RegisterSearchRpcServer(s *grpc.Server, srv SearchRpcServer) {
	s.RegisterService(&_SearchRpc_serviceDesc, srv)
}

func _SearchRpc_Alpha_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AlphaRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SearchRpcServer).Alpha(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/searchRpc.SearchRpc/Alpha",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SearchRpcServer).Alpha(ctx, req.(*AlphaRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _SearchRpc_serviceDesc = grpc.ServiceDesc{
	ServiceName: "searchRpc.SearchRpc",
	HandlerType: (*SearchRpcServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Alpha",
			Handler:    _SearchRpc_Alpha_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "searchRpc.proto",
}

func init() { proto.RegisterFile("searchRpc.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 511 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x6c, 0x93, 0xcf, 0x6e, 0xd3, 0x40,
	0x10, 0xc6, 0x71, 0x9c, 0x7f, 0x9e, 0xb4, 0xa4, 0x5d, 0x95, 0xb2, 0x8a, 0x10, 0x8a, 0x22, 0x84,
	0x72, 0x40, 0x11, 0x2a, 0x17, 0x84, 0xe0, 0x40, 0x11, 0x11, 0x15, 0x17, 0x64, 0x24, 0xee, 0x5b,
	0x67, 0x9a, 0x58, 0xde, 0xec, 0x9a, 0xdd, 0x75, 0x20, 0x6f, 0xc3, 0xc3, 0xf1, 0x20, 0xd5, 0x8e,
	0xed, 0xc4, 0x69, 0x7a, 0xca, 0x7c, 0x33, 0xb3, 0xd9, 0xf9, 0x7e, 0xe3, 0x85, 0xa1, 0x45, 0x61,
	0x92, 0x55, 0x9c, 0x27, 0xb3, 0xdc, 0x68, 0xa7, 0x59, 0xb4, 0x4b, 0x4c, 0xfe, 0x05, 0x70, 0xf2,
	0x59, 0xe6, 0x2b, 0x11, 0xe3, 0xef, 0x02, 0xad, 0x63, 0x0c, 0xda, 0x0e, 0xcd, 0x9a, 0x07, 0xe3,
	0x60, 0x1a, 0xc5, 0x14, 0x33, 0x0e, 0x3d, 0x53, 0x28, 0x97, 0xae, 0x91, 0xb7, 0x28, 0x5d, 0x4b,
	0xf6, 0x02, 0x22, 0xfc, 0xeb, 0x50, 0xd9, 0x54, 0x2b, 0x1e, 0x52, 0x6d, 0x9f, 0x60, 0x23, 0xe8,
	0x17, 0x16, 0x8d, 0x12, 0x6b, 0xe4, 0x6d, 0x2a, 0xee, 0x34, 0x3b, 0x83, 0x50, 0x48, 0xc9, 0x3b,
	0xe3, 0x60, 0xda, 0x8f, 0x7d, 0xc8, 0x2e, 0xa1, 0xbb, 0x94, 0xfa, 0x56, 0x48, 0xde, 0xa5, 0x64,
	0xa5, 0x26, 0x19, 0x9c, 0x56, 0x13, 0xda, 0x5c, 0x2b, 0x8b, 0xec, 0x2d, 0xf4, 0x0c, 0xda, 0x42,
	0x3a, 0xcb, 0x83, 0x71, 0x38, 0x1d, 0x5c, 0x5d, 0xce, 0xf6, 0x0e, 0xeb, 0xd6, 0x42, 0xba, 0xb8,
	0x6e, 0x63, 0x17, 0xd0, 0x71, 0xda, 0x09, 0x49, 0xe3, 0x87, 0x71, 0x29, 0xc8, 0xaa, 0xd6, 0x19,
	0xcd, 0x1d, 0xc6, 0x14, 0x4f, 0xfe, 0xb7, 0x61, 0xd0, 0xf8, 0x0b, 0x3f, 0x94, 0x55, 0x69, 0x7e,
	0xb3, 0xa8, 0x80, 0x54, 0xea, 0xc0, 0x5a, 0xeb, 0xd8, 0x5a, 0x86, 0xdb, 0x0a, 0x87, 0x0f, 0x9b,
	0x00, 0xdb, 0x87, 0x00, 0x39, 0xf4, 0xee, 0x0a, 0x29, 0xbf, 0xe3, 0x96, 0xb3, 0xb2, 0x52, 0xc9,
	0x43, 0xb4, 0xf0, 0x10, 0x2d, 0x83, 0xb6, 0x9f, 0x84, 0xf8, 0x45, 0x31, 0xc5, 0x6c, 0x0c, 0x03,
	0xff, 0xfb, 0x0b, 0x0d, 0x9d, 0xe9, 0x92, 0xad, 0x66, 0xca, 0xdf, 0x96, 0x18, 0x14, 0x0e, 0x17,
	0xbc, 0x4f, 0xd5, 0x5a, 0x12, 0x0b, 0xb1, 0xb4, 0x3c, 0x1a, 0x87, 0xb4, 0x76, 0xb1, 0xb4, 0x6c,
	0x0e, 0xb0, 0x4a, 0x97, 0x2b, 0x99, 0x2e, 0x57, 0xce, 0xf2, 0x01, 0xa1, 0x7e, 0xfd, 0x38, 0xea,
	0xd9, 0xb7, 0x5d, 0xe3, 0x57, 0xe5, 0xcc, 0x36, 0x6e, 0x9c, 0x64, 0x6f, 0xe0, 0xfc, 0x4e, 0x9b,
	0x0c, 0x17, 0x73, 0xa3, 0xd7, 0xf3, 0xca, 0xed, 0x09, 0x0d, 0x7e, 0x5c, 0x38, 0xec, 0xae, 0xbd,
	0x9c, 0xd2, 0xb4, 0xc7, 0x05, 0xbf, 0x07, 0x53, 0xa8, 0x2f, 0xba, 0x50, 0x8e, 0x3f, 0xa5, 0xa6,
	0x9d, 0x66, 0x2f, 0x01, 0x12, 0xa9, 0x15, 0x96, 0xd5, 0x21, 0x55, 0x1b, 0x19, 0xcf, 0x6b, 0x81,
	0x36, 0x31, 0x69, 0xee, 0xfc, 0x1d, 0x67, 0x34, 0x51, 0x33, 0xe5, 0x79, 0xe5, 0x26, 0xdd, 0x08,
	0x87, 0xfc, 0xbc, 0xdc, 0x4e, 0x25, 0x47, 0x9f, 0x60, 0xf8, 0xc0, 0x72, 0xbd, 0xf6, 0x60, 0xbf,
	0xf6, 0x0b, 0xe8, 0x6c, 0x84, 0x2c, 0xea, 0x2f, 0xa4, 0x14, 0x1f, 0x5a, 0xef, 0x83, 0xab, 0x1b,
	0x88, 0x7e, 0xd6, 0x1c, 0xd9, 0x47, 0xe8, 0x10, 0x4a, 0xf6, 0xfc, 0x18, 0x2e, 0x3d, 0xca, 0x11,
	0x7f, 0x84, 0x3a, 0xbd, 0x85, 0xc9, 0x93, 0xeb, 0x57, 0xf0, 0x2c, 0xd5, 0xb3, 0xec, 0x4f, 0x36,
	0xb3, 0x68, 0x36, 0x69, 0x82, 0x55, 0xef, 0xf5, 0xfe, 0x86, 0x1f, 0xc1, 0x6d, 0x97, 0x5e, 0xfe,
	0xbb, 0xfb, 0x00, 0x00, 0x00, 0xff, 0xff, 0x26, 0x52, 0xea, 0xf8, 0x0c, 0x04, 0x00, 0x00,
}
